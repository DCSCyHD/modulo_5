---
title: "Modelado de tópicos Vol. 1. Latent Dirichlet Allocation"
subtitle: "Los diarios de Emilio Renzi (tres tomos)"
output: html_notebook
---

```{r echo=TRUE, results='hide'}
library(tidyverse)
library(topicmodels)
library(tidytext)
library(tictoc)
```


## Introducción
En la minería de texto, suele ser habiutal disponer de grandes volúmenes de texto (publicaciones de blogs, artículos de noticias, comentarios, etc.) a los cuales nos gustaría poder "dividir" en grupos naturales para poder entenderlos por separado. El modelado de tópicos es un método para la clasificación no supervisada de dichos documentos, similar a la agrupación de datos numéricos, que encuentra grupos naturales de elementos incluso cuando no estamos seguros de lo que estamos buscando.

Hay una gran cantidad de métodos de modelados de tópicos, hoy vamos a ver uno de los más populares: Latent Dirichlet Allocation (LDA). La idea va a ser tratar cada documento como una mixtura, una mezcla de temas y a cada tema como una mixtura de palabras. Esto permite que los documentos se "superpongan" entre sí en términos de contenido, en lugar de estar separados en grupos discretos, de una manera que refleja el uso típico del lenguaje natural.

![](https://www.tidytextmining.com/images/tmwr_0601.png)


## Latent Dirichlet Allocation (LDA). ¿De qué hablan los presidentes en Argentina?

LDA es uno de los algoritmos más comunes para el modelado de tópicos Sin sumergirnos en las matemáticas detrás del modelo, podemos entenderlo como guiado por dos principios.

- Cada documento es una mezcla de temas. Imaginamos que cada documento puede contener palabras de varios temas en proporciones particulares. Por ejemplo, en un modelo de dos temas podríamos decir "El documento 1 es 90% tema A y 10% tema B, mientras que el documento 2 es 30% tema A y 70% tema B".
- Cada tema es una mezcla de palabras. Por ejemplo, podríamos imaginar un modelo de dos temas de noticias estadounidenses, con un tema para "política" y otro para "entretenimiento". Las palabras más comunes en el tema de política pueden ser "presidente", "Congreso" y "gobierno", mientras que el tema de entretenimiento puede estar compuesto por palabras como "películas", "televisión" y "actor". Es importante destacar que las palabras se pueden compartir entre temas; una palabra como "presupuesto" puede aparecer en ambos por igual.

LDA es un método matemático para estimar ambos al mismo tiempo: encontrar la combinación de palabras que está asociada con cada tema, al mismo tiempo que se determina la combinación de temas que describe cada documento. Hay varias implementaciones de este algoritmo y exploraremos una de ellas en profundidad.

Veamos un ejemplo:

```{r}
revistas <- read_csv('../data/revistas_limpias_final.csv')

head(revistas)
```

Disponemos de este dataset que contiene artículos tomados de dos revistas con diferentes targets:

- Ohlala, cuyo target son mujeres
- Brando, destinada a hombres

Estamos interesados en poder identificar qué temas existen en las revistas para hombres y mujeres cada uno pero no estamos interesados en leer todos los discursos. Por eso vamos a usar LDA en este corpus.

Como vemos, el corpus aún no ha sido procesado. Empecemos, entonces, por ahí y podemos, de paso, repasar las diferentes etapas.

## Preprocesamiento

Vamos a normalizar, primero, los campos de texto. Con esta instrucción cambiamos el encoding de texto de los campos `text` y `title` y lo pasamos a ASCII. Esta es una forma bastante rápida de eliminar tildes, ñ y otros acentos.

```{r}
revistas <- revistas %>%
                mutate(text = stringi::stri_trans_general(text, "Latin-ASCII"),
                       titulo = stringi::stri_trans_general(titulo, "Latin-ASCII"))
```

Eliminamos los dígitos que encontremos en el texto...

```{r}
revistas <- revistas %>%
          mutate(text = str_replace_all(text, '[[:digit:]]+', ''))
```



Ahora podemos tokenizarlo:

```{r}
revistas_tidy <- revistas %>%
                unnest_tokens(word, text)
```

Hagamos una exploración rápida:

```{r}
revistas_tidy %>%
        group_by(word) %>%
        summarise(n=n()) %>%
        arrange(desc(n))
```

Vemos que, claramente, tenemos que hacer una limpieza de stopwords.

```{r}
stop_words <- read_delim('../data/stopwords.txt', 
                         delim = '\t',
                         col_names = c('word')) %>%
                        mutate(word=stringi::stri_trans_general(word, "Latin-ASCII"))


## Aquí agregamos algunas palabras al listado de stopwords...
stop_words <- stop_words %>%
                bind_rows( tibble(word=c('ano', 'anos', 'ohlala', 'foto', 'the'))) #lexicon=c('custom', 'custom')))
```

```{r}
revistas_tidy <- revistas_tidy %>%
                anti_join(stop_words)
```

Veamos ahora:

```{r}
revistas_tidy %>%
        group_by(word) %>%
        summarise(n=n()) %>%
        arrange(desc(n))
```

#### Pregunta
¿Cómo podríamos identificar las palabras más usadas cada grupo de revista?

```{r}
####
```

Ahora sí, estamos en condiciones de avanzar en nuestro modelado de tópicos.

### Modelado de tópicos
Para hacer el modelado de temas como se implementa aquí, necesitamos generar una `DocumentTermMatrix`, un tipo especial de matriz del paquete tm (por supuesto, esto es solo una implementación específica del concepto general de una TFM). 

Las filas corresponden a documentos (textos descriptivos en nuestro caso) y las columnas corresponden a términos (es decir, palabras); es una matriz dispersa y los valores son recuentos de palabras. Primero, generamos nuestra tabla tidy de conteos

```{r}
word_counts <- revistas_tidy %>%
        group_by(id, word) %>%
        summarise(n=n()) %>%
        ungroup()
```

Tenemos hasta aquí nuestra estructura de datos habitual: un token por fila y una columna de conteo. Vamos a transformarla ahora a una TFM:

```{r}
disc_dtm <- word_counts %>%
                cast_dtm(id, word, n)

disc_dtm
```

Vemos que este conjunto de datos contiene documentos (cada uno de ellos un discurso) y términos (palabras). Observe que esta matriz de documento-término de ejemplo es (muy cercana a) 100% dispersa, lo que significa que casi todas las entradas en esta matriz son cero. Cada entrada distinta de cero corresponde a una determinada palabra que aparece en un determinado documento.


### Ahora sí, vamos a modelar los tópicos
Ahora usemos el paquete `topicmodels` para estimar un modelo LDA. ¿Cuántos temas le diremos al algoritmo que haga? Esta es una pregunta muy parecida a la de un clustering de k-medias. La respuesta es desilusionadora: no lo sabemos. No queda otra opción que ir probando. Por ahora y a los fines prácticos de esta primera aproximación vamos a probar un modelo muy simple: 4 temas.

```{r}
tic()
lda_2 <- LDA(disc_dtm, k=4, control = list(seed = 1234))
lda_2
toc()
```

Vemos que entrenar el modelo es simple: una línea de código. Lo difícil viene ahora.

### La interpretación


```{r}
ap_topics <- tidy(lda_2, matrix = "beta")
ap_topics
```

La funciín `tidy`conviritó el modelo a un formato de un tópico-término por fila. Para cada combinación, el modelo calcula la probabilidad de que ese término se genere a partir de ese tópico. Por ejemplo, el término "cesped" tiene una probabilidad de 3.21x10-13  de ser generado a partir del tema 1. Esta valor baja sensiblemente en el resto de los tópicos.

Podríamos usar el `slice_max()` de `dplyr` para encontrar los 15 términos que son más comunes dentro de cada tema. Como marco de datos ordenado, esto se presta bien a una visualización de `ggplot2`.

```{r}
ap_top_terms <- ap_topics %>%
  group_by(topic) %>%
  slice_max(beta, n = 20) %>% 
  ungroup() %>%
  arrange(topic, -beta)


ap_top_terms %>%
  mutate(term = reorder_within(term, beta, topic)) %>%
  ggplot(aes(beta, term, fill = factor(topic))) +
  geom_col(show.legend = FALSE) +
  facet_wrap(~ topic, scales='free_y') +
  scale_y_reordered() +
  theme_minimal()
```

EXPLICAR

```{r}
doc_2_topics <- tidy(lda_2, matrix = "gamma")

doc_2_topics %>%
  rename(id = document) %>%
  mutate(id = as.integer(id)) %>%
  left_join(revistas %>% select(id, categoria) %>% unique()) %>%
  group_by(categoria, topic) %>%
    summarise(mean = mean(gamma)*100
              )
```


EXPLICAR



```{r}
library(tictoc)

tic()
lda_50 <- LDA(disc_dtm, k=10, control = list(seed = 9875))
lda_50
toc()

write_rds(lda_50, '../models/lda_10.rds')
```

```{r}
ap_topics_10 <- tidy(lda_50, matrix = "beta")

ap_top_terms <- ap_topics_10 %>%
  group_by(topic) %>%
  slice_max(beta, n = 20) %>% 
  ungroup() %>%
  arrange(topic, -beta)


ap_top_terms %>%
  mutate(term = reorder_within(term, beta, topic)) %>%
  ggplot(aes(beta, term, fill = factor(topic))) +
  geom_col(show.legend = FALSE) +
  facet_wrap(~ topic, scales='free_y') +
  scale_y_reordered()
```

```{r}
doc_2_topics <- tidy(lda_50, matrix = "gamma")

doc_2_topics %>%
  rename(id = document) %>%
  mutate(id = as.integer(id)) %>%
  left_join(revistas %>% select(id, categoria) %>% unique()) %>%
  group_by(categoria, topic) %>%
    summarise(mean = mean(gamma)*100
              )
```

